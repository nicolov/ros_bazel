"""
Interop with ROS-based tooling.
"""

load("@com_github_nicolov_ros_bazel//:tools/path_utils.bzl",
    "basename",
)
load("@com_github_nicolov_ros_bazel//:tools/ros_global_tools.bzl",
    "ROS_GLOBAL_TOOLS",
)

PACKAGE_XML_TEMPLATE = """
<package format="2">
  <name>{pkg_name}</name>
  <version>0.0.1</version>
  <description>
    shim
  </description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>BSD</license>
  <buildtool_depend>catkin</buildtool_depend>
</package>
"""

def _write_package_xml_impl(ctx):
    # Generate __init__.py for top-level package
    ctx.file_action(
        output=ctx.outputs.out,
        content=PACKAGE_XML_TEMPLATE.format(
            pkg_name=ctx.attr.ros_package_name),
    )


_write_package_xml = rule(
    implementation = _write_package_xml_impl,
    attrs = {
        'ros_package_name': attr.string(mandatory=True),
        'out': attr.output(mandatory=True),
    },
)

def catkin_package(ros_package_name):
    """ Generate a package.xml in the bazel out folder, so that the
    package executables can be picked up by rosrun. """

    _write_package_xml(
        ros_package_name = ros_package_name,
        out = 'package.xml',
        name = 'package_xml',
    )

#
#

def _symlink_file_impl(ctx):
    input_file = list(ctx.attr.src.files)[0]

    ctx.action(
        inputs = [input_file],
        outputs = [ctx.outputs.dest],
        command = 'ln -sf `readlink -f %s` %s' % (
            input_file.path,
            ctx.outputs.dest.path,
        ),
    )

_symlink_file = rule(
    implementation = _symlink_file_impl,
    attrs = {
        'src': attr.label(mandatory=True, allow_files=True, single_file=True),
        'dest': attr.output(mandatory=True),
    })

#
#

def symlink_files(srcs):
    # Symlink files to the build space, for example .launch files

    for src in srcs:
        _symlink_file(
            name = 'symlink_' + basename(src),
            src = src,
            dest = 'share/' + src,
        )

#
#

def add_extension(src, ext):
    _symlink_file(
        name = 'add_extension_%s_%s' % (src, ext),
        src = src,
        dest = src + ext,
    )

def add_py_extension(src):
    add_extension(
        src = src,
        ext = '.py',
    )

#
#

SETUP_BASH_TPL = """\
#!/usr/bin/bash

"""

def _generate_setup_bash_impl(ctx):
    paths = depset()
    for str_label in ROS_GLOBAL_TOOLS:
        label = Label(str_label)

        paths += [label.workspace_root]

    path_lines = [
        'export PATH="bazel-bin/{}:$PATH"'.format(p)
        for p in paths
    ]

    # Write
    ctx.file_action(
        output = ctx.outputs.out,
        content = SETUP_BASH_TPL + '\n'.join(path_lines) + '\n',
        executable = True,
    )

_generate_setup_bash = rule(
    implementation = _generate_setup_bash_impl,
    attrs = {
        'out': attr.output(mandatory=True),
    },
)

def generate_setup_bash():
    # Expose tools in the root BUILD so that they're built with //...
    for ros_tool_label in ROS_GLOBAL_TOOLS:
        native.alias(
            name = ros_tool_label.split(':')[-1],
            actual = ros_tool_label)

    _generate_setup_bash(
        name = 'setup_bash',
        out = 'setup.bash',
    )

#
#

def _py_import_shim_impl(ctx):
    SHIM_TPL = """
# Shim to import the actual python code stored in the typical
# src/pkg_name directory that catkin packages use.
# Generated by ros_interop.bzl:py_import_shim

from os.path import join
__path__.insert(0, join(__path__[0], 'src', '{py_module_name}'))
execfile(join(__path__[0], '__init__.py'))
"""

    ctx.file_action(
        output = ctx.outputs.out,
        content = SHIM_TPL.format(
            py_module_name = ctx.attr.py_module_name),
    )

_py_import_shim = rule(
    implementation = _py_import_shim_impl,
    attrs = {
        'py_module_name': attr.string(mandatory=True),
        'out': attr.output(mandatory=True),
    })


def py_import_shim(py_module_name):
    """Generate a shim __init__.py that forwards the python import from the
    top external/repo directory to the actual python code.

    Generating and adding this __init__.py to the py_library enables
    naming the external repo the same as the python module that it contains.
    The source of the problem is the typical hierarchy of files in a catkin
    package, and the fact the the python source code is not at the root.
    When declaring a python library from such a package, the upstream
    __init__.py typically resides under `src/rospy/__init__.py` or similar.
    This means that bazel will not find any __init__.py and happily generate
    an empty one to make sure that the external repo is importable. The
    directory structure in the runfiles end up looking like this:

    talker_py
    talker_py.runfiles
        MANIFEST
        __init__.py              <- autogenerated, but correct
        rospy                    <- name of the external repo
            __init__.py          <- autogenerated, *bad*
            src
                __init__.py      <- autogenerated, not a problem per se
                rospy
                    __init__.py  <- actual upstream __init__
                    code.py

    When the external repo has the same name as the module it contains,
    python picks up the first __init__.py, and never loads the actual
    upstream code that's nested within `src/rospy`.
    """

    _py_import_shim(
        name = 'import_shim',
        py_module_name = py_module_name,
        out = '__init__.py',
    )


def catkin_python_library(py_module_name, **kwargs):
    """Utility macro for catkin-based python modules. Just forwards to the
    native py_library, but generates a shim that fixes imports."""

    # Sane defaults for the most common structure.
    if not 'srcs' in kwargs:
        kwargs['srcs'] = native.glob(['src/**/*.py'])

    # Add import shim
    kwargs['srcs'] += ['__init__.py']

    if not 'imports' in kwargs:
        kwargs['imports'] = ['src']

    native.py_library(
        **kwargs
    )

    py_import_shim(
        py_module_name = py_module_name,
    )
